<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Palm Capture (fixed)</title>
  <style>
    *{box-sizing:border-box;margin:0;padding:0}
    body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;background:#222;min-height:100vh;display:flex;align-items:center;justify-content:center;color:#fff}
    .container{width:92%;max-width:760px}
    .camera-container{position:relative;width:100%;aspect-ratio:16/9;border-radius:12px;overflow:hidden;background:#000}
    #video{position:absolute;inset:0;width:100%;height:100%;object-fit:contain;transform:scaleX(-1)} /* mirror only the video */
    .hand-guide{position:absolute;inset:0;pointer-events:none;z-index:10} /* no mirror here */
    .palm-svg{
      position:absolute;
      inset:0;              /* fill the camera container */
      width:100%;
      height:100%;
      transform:none;       /* IMPORTANT: no translate */
      overflow:visible;
    }
        .palm-outline{fill:none;stroke:rgba(0,255,0,.8);stroke-width:3;stroke-dasharray:8 4;filter:url(#glow);transition:stroke .12s ease, stroke-width .12s ease, filter .12s ease}
    .palm-outline.good{
      stroke:#00fff2;
      stroke-width:5;                 /* thicker */
      stroke-dasharray:none;
      stroke-linecap:round;
      stroke-linejoin:round;
      /* big stacked glow */
      filter: drop-shadow(0 0 6px rgba(0,255,242,.35));

    }

    /* dim the video when ‚Äúgood‚Äù for extra contrast */
    .camera-container.good #video{
      filter:brightness(.55) contrast(1.25) saturate(1.1);
    }
        .finger-dot{fill:#00e5ff;stroke:#fff;stroke-width:1}
        .status{margin-top:10px;padding:10px;border-radius:8px;font-weight:700}
        .status.ready{background:rgba(76,175,80,.16);border:1px solid #4CAF50;color:#4CAF50}
        .status.error{background:rgba(244,67,54,.16);border:1px solid #f44336;color:#f44336}
        .controls{display:flex;gap:8px;justify-content:center;margin-top:10px}
        button{background:#4CAF50;border:0;color:#fff;padding:10px 18px;border-radius:999px;cursor:pointer}
        button:disabled{opacity:.6;cursor:not-allowed}
        .capture-btn{background:#e45}
  </style>
</head>
<body>
  <div class="container">
    <div class="camera-container">
      <video id="video" autoplay muted playsinline></video>

      <div class="hand-guide">
        <svg class="palm-svg" viewBox="0 0 316.8 430.41" preserveAspectRatio="xMidYMid meet">
          <defs>
            <filter id="glow">
              <feGaussianBlur stdDeviation="2" result="b"/>
              <feMerge><feMergeNode in="b"/><feMergeNode in="SourceGraphic"/></feMerge>
            </filter>
          </defs>

          <g id="flip-left" transform="translate(-320,-20)">

          <!-- live fingertip debug dots -->
          <g id="debug-dots"></g>

          <!-- fingertip targets (thumb -> pinky) in viewBox units -->
            <g id="targets" fill="black">

                <circle id="t0" cx="123" cy="238" r="12"/>  <!-- thumb -->
                <circle id="t1" cx="123" cy="238" r="12"/>  <!-- index -->
                <circle id="t2" cx="123" cy="238" r="12"/>  <!-- middle -->
                <circle id="t3" cx="123" cy="238" r="12"/>  <!-- ring -->
                <circle id="t4" cx="123" cy="238" r="12"/>  <!-- pinky -->
                <circle id="t5" cx="123" cy="238" r="14"/>  <!-- palm -->
            </g>

          <!-- outline -->
          <path id="outline" class="palm-outline"
            d="m293.12 154.31c-1.187-0.007-2.4908 0.14375-3.9062 0.46875-1.654 0.381-5.9352 3.7758-7.1562 5.7188-5.857 9.331-3.3628 32.779-3.5938 47.281 0.39025 15.233 2.9204 30.087 0.71875 44.438-5.7953 18.424 6.6761 79.039-10.719 55.906-3.865-13.098-3.7128-26.528-6.4688-39.438-2.313-10.837-7.553-18.441-10.75-29.375-3.253-11.125-4.0165-23.033-6.4375-36.531-2.5845-11.757-4.192-30.66-16.469-30.094-4.235 0.313-11.087 7.5565-12.906 12.188-2.338 5.955-2.7642 15.3-2.1562 24.344 0.506 7.548 2.6182 16.95 5.0312 26.531 2.226 8.834 2.6592 18.112 4.2812 27.219 1.958 11.007 3.6798 24.304 6.4688 35.844 1.106 4.581 1.4818 10.123 2.8438 16.469 1.735 8.072 3.9748 15.122-4.2812 17.906-9.868-4.702-13.419-16.71-17.473-27.228-4.0209-6.8333-15.709-23.025-19.808-31.522-5.5156-10.571-9.433-34.282-20.062-34.406-10.618 0.127-13.053 15.803-10.75 29.375 2.9086 13.013 10.359 23.442 15.781 34.406 7.894 15.721 15.691 34.516 24.344 50.875-0.27973 24.311 3.3662 45.243 5.75 68.062 1.189 9.402 3.8988 21.991 5.7188 32.25 4.8748 20.737 11.765 41.04 16.623 61.234 1.8913 7.8614 7.4745 15.706 8.511 23.553 0.49491 3.747 0.86513 7.4946 1.0846 11.245 0.291 4.541 0.13202 26.932 0.64102 31.6 2.7381 0.60062 2.6746 0.73178 4.3902 0.77474 1.344-12.563-0.56775-32.846-0.71875-44.562-1.5202-7.0776-7.273-14.302-9.1449-21.59-7.3446-28.597-16.522-58.18-20.668-83.753-0.826-5.373-1.4532-9.7765-2.1562-17.188-1.7211-16.896-6.8855-33.727-5.3125-49.594l-1.0938-13.5c-0.0109 0.01-0.0204 0.0215-0.0312 0.0312-2.315-5.895-5.7368-11.104-8.5938-17.188-2.664-5.674-4.2822-12.188-7.1562-18.625-6.6482-6.9826-8.3089-16.538-12.188-23.656-7.3226-9.9401-13.434-26.327-12.188-37.25 0.613-4.46 2.1814-11.269 5-12.188 2.8402-0.50157 4.2424 0.49634 5.75 1.4375 4.059 5.17 5.495 11.468 7.875 17.906 2.651 7.18 5.8822 16.75 10.031 22.938 5.1781 6.8446 9.7482 13.941 14.263 20.594 4.324 6.734 6.7994 14.572 10.83 21.688 1.192 2.1023 3.0563 3.4189 4.1562 5.375 9.0863 2.9243 11.891 1.7205 16.625-5.4062 0.362-14.783-7.3795-31.402-9.3125-50.156-1.2274-10.367-3.1456-19.472-4.3125-27.938-0.20887-11.874-3.267-19.981-5-30.812-0.918-5.314-3.398-14.044-2.875-21.5 0.567-8.118 5.351-21.686 13.625-20.781 4.803 0.526 6.009 5.2872 7.1174 9.3514 3.599 14.671 4.8939 27.899 7.9139 41.524 2.8767 11.755 4.8374 20.948 8.5938 28.656 1.987 4.551 5.2518 11.769 6.4688 19.375 2.0606 12.892 2.1181 25.7 7.875 37.938 0.004 0.009-0.004 0.0226 0 0.0312h0.1875c6.0305 4.5999 10.519 3.3961 12.719-2.1562 4.759-16.692-2.0885-41.966 3.5625-60.188 2.2701-11.357-0.80138-43.253-1.4375-65.938-0.26546-9.4663-1.1262-18.122 3.5938-25.062 12.967-8.424 19.108 7.4128 20.781 19.344 1.974 14.08 0.81525 30.2 2.1562 46.562 0.339 4.108 1.6302 8.2215 2.1562 12.188 0.573 4.313 1.522 7.9995 2.125 12.188 2.9867 20.715-3.1271 42.028 0.6875 60 6.5388 24.952 23.743-22.153 26.562-29.906 5.219-12.997 11.593-26.931 16.469-39.406 1.469-3.844 2.6248-7.6298 3.5938-11.469 2.8923-12.511 8.8459-35.173 19.344-39.406 8.092-0.758 11.395 3.1538 10.031 16.469-1.543 14.897-7.9702 31.998-10.781 48-1.0999 10.395-4.4316 19.755-7.1562 29.375-4.198 12.434-13.396 28.433-15.062 43-1.1686 27.23 0.97779 54.387 8.4062 75.562 7.8574 4.3914 13.184-1.8571 18.125-6.4688 3.185-2.94 5.8708-6.4565 8.5938-9.3125 6.367-6.681 12.485-11.41 17.094-17.906 4.1315-8.2934 10.768-13.988 18.031-18.625 7.211-4.657 12.308-7.127 20.781-7.875 6.6039-1.8383 11.742 0.8728 18.625 2.125 1.872 1.525 3.3758 2.0725 3.5938 4.3125 0.5 5.127-4.7832 6.0317-10.031 9.0357-18.749 12.648-36.516 28.751-48.031 46.839-2.078 12.971-7.6342 22.472-15.031 30.125-1.521 2.229-9.1468 8.717-10.969 10-9.633 15.924-13.071 23.526-22 40.156-20.587 12.661-21.009 51.245-11.281 75.656 1.017 9.016 5.303 17.38 9.125 22.938 1.6772-"
          />
          </g>

        </svg>
      </div>
    </div>

    <div id="status" class="status ready">üì∑ Camera ready - match the green outline</div>
    <div class="controls">
      <button id="startBtn" onclick="startCamera()">Start</button>
      <button id="captureBtn" class="capture-btn" onclick="captureImage()" disabled>Capture</button>
      <button id="stopBtn" onclick="stopCamera()" disabled>Stop</button>
    </div>
  </div>

  <script>
    let stream=null, rafId=null, hands=null;
    const video = document.getElementById('video');
    const statusEl = document.getElementById('status');
    const startBtn = document.getElementById('startBtn');
    const captureBtn = document.getElementById('captureBtn');
    const stopBtn = document.getElementById('stopBtn');

    const cameraBox = document.querySelector('.camera-container');
    const palmSvg = document.querySelector('.palm-svg');
    const palmOutline = document.querySelector('.palm-outline');
    const overlaySpace = document.getElementById('flip-left'); // the flipped <g>


    const tipIds = [4,8,12,16,20,0]; // thumb -> pinky
    const targetEls = [
      document.getElementById('t0'),
      document.getElementById('t1'),
      document.getElementById('t2'),
      document.getElementById('t3'),
      document.getElementById('t4'),
      document.getElementById('t5')
    ];

    // --- helpers ---
    
    function ensureDebugDots(n=6){
      const g = document.getElementById('debug-dots');
      while(g.childElementCount<n){
        const c = document.createElementNS('http://www.w3.org/2000/svg','circle');
        c.setAttribute('r','6'); c.setAttribute('class','finger-dot');
        g.appendChild(c);
      }
      return g.children;
    }

    // map normalized landmark to *screen* pixels (with object-fit: contain)
function lmToScreenXY(lm){
  const box = getVideoContentRect();           // <-- use actual content rect
  // MediaPipe + selfieMode:true already mirror to match our mirrored video
  return { x: box.x + lm.x * box.width, y: box.y + lm.y * box.height };
}

    // screen px -> svg viewBox units
    function screenToSvgXY(svg, x, y){
  const pt = palmSvg.createSVGPoint(); // must come from the root <svg>
  pt.x = x; pt.y = y;
  return pt.matrixTransform(overlaySpace.getScreenCTM().inverse());
    }

    // svg viewBox -> screen px
    function svgToScreenXY(svg, x, y){
  const pt = palmSvg.createSVGPoint(); // must come from the root <svg>
  pt.x = x; pt.y = y;
  return pt.matrixTransform(overlaySpace.getScreenCTM());
    }

    function drawLiveTipDots(landmarks){
      const lm = landmarks[0]; if(!lm) return;
      const dots = ensureDebugDots(6);
      for(let i=0;i<tipIds.length;i++){
        const tip = lm[tipIds[i]]; if(!tip) continue;
        const sp = lmToScreenXY(tip);
        const vp = screenToSvgXY(palmSvg, sp.x, sp.y);
        const dot = dots[i];
        dot.setAttribute('cx', vp.x);
        dot.setAttribute('cy', vp.y);
      }
    }

    // per-finger distances in *screen* pixels
    function tipDistancesPX(landmarks){
    const lm = landmarks[0]; if(!lm) return [];
    const dists = [];
    for (let i=0;i<tipIds.length;i++){
        const tip = lm[tipIds[i]]; if(!tip) continue;
        const p1 = lmToScreenXY(tip);                    // live (camera) point
        const tEl = targetEls[i];
        const cx = +tEl.getAttribute('cx'), cy = +tEl.getAttribute('cy');
        const p2 = svgToScreenXY(palmSvg, cx, cy);       // target (SVG) point
        dists.push(Math.hypot(p1.x - p2.x, p1.y - p2.y));
    }
    return dists;
    }
    const MATCH_FRACTION = 0.10; // tighten/loosen here

    // helper: are *all* tips close enough?
    function allTipsClose(landmarks){
      const dists = tipDistancesPX(landmarks);
      if (dists.length < 6) return false;               // need all five tips

      // threshold ~3.5% of the smallest camera dimension (tweak to taste)
      const box = cameraBox.getBoundingClientRect();
      const threshold = Math.min(box.width, box.height) * MATCH_FRACTION;

      return dists.every(d => d <= threshold);
    }

    function installHands(){
    hands = new Hands({
        locateFile: f => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}`
    });
    hands.setOptions({
        selfieMode:true,
        maxNumHands:1,
        modelComplexity:1,
        minDetectionConfidence:0.6,
        minTrackingConfidence:0.6
    });
    hands.onResults(res=>{
        if(!res.multiHandLandmarks || res.multiHandLandmarks.length===0){
        palmOutline.classList.remove('good');
        cameraBox.classList.remove('good');  // <‚Äî add this

        return;
        }
        drawLiveTipDots(res.multiHandLandmarks);

        // highlight only when each fingertip is inside the threshold
        if (allTipsClose(res.multiHandLandmarks)) {
        palmOutline.classList.add('good');
        cameraBox.classList.add('good');     // <‚Äî and this

        } else {
        palmOutline.classList.remove('good');
        cameraBox.classList.remove('good');  // <‚Äî and this

        }
    });
    }


    function startHighlightLoop(){
      if(!hands) return;
      async function tick(){
        await hands.send({image:video});
        rafId = requestAnimationFrame(tick);
      }
      cancelAnimationFrame(rafId);
      rafId = requestAnimationFrame(tick);
    }
    function stopHighlightLoop(){ cancelAnimationFrame(rafId); rafId=null; }

      function getVideoContentRect() {
    const r = video.getBoundingClientRect();
    const vw = video.videoWidth || 1280;
    const vh = video.videoHeight || 720;
    if (!vw || !vh) return { x: r.left, y: r.top, width: r.width, height: r.height };

    const elAR = r.width / r.height;
    const vidAR = vw / vh;

    if (vidAR > elAR) {
      // letterbox top/bottom
      const contentW = r.width;
      const contentH = r.width / vidAR;
      const y = r.top + (r.height - contentH) / 2;
      return { x: r.left, y, width: contentW, height: contentH };
    } else {
      // letterbox left/right
      const contentH = r.height;
      const contentW = r.height * vidAR;
      const x = r.left + (r.width - contentW) / 2;
      return { x, y: r.top, width: contentW, height: contentH };
    }
  }

    // --- camera controls ---
    async function startCamera(){
      try{
        statusEl.textContent='üîÑ Starting camera...';
        statusEl.className='status';
        stream = await navigator.mediaDevices.getUserMedia({
          video:{ width:{ideal:1280}, height:{ideal:720}, facingMode:'user' }
        });
        video.srcObject = stream;
        video.onloadedmetadata = ()=>{
          statusEl.textContent='üì∑ Camera ready - match the green outline';
          statusEl.className='status ready';
          startBtn.disabled=true; captureBtn.disabled=false; stopBtn.disabled=false;
          document.querySelector('.camera-container').style.aspectRatio =
            `${video.videoWidth} / ${video.videoHeight}`;
          installHands();
          startHighlightLoop();
        };
      }catch(e){
        console.error(e);
        statusEl.textContent='‚ùå Camera access denied or not available';
        statusEl.className='status error';
      }
    }
    function stopCamera(){
      if(stream){ stream.getTracks().forEach(t=>t.stop()); stream=null; video.srcObject=null; }
      stopHighlightLoop();
      statusEl.textContent='üì∑ Camera stopped'; statusEl.className='status';
      startBtn.disabled=false; captureBtn.disabled=true; stopBtn.disabled=true;
    }
    function captureImage(){
      if(!stream){ statusEl.textContent='‚ùå Camera not started'; statusEl.className='status error'; return; }
      const c=document.createElement('canvas'), ctx=c.getContext('2d');
      c.width=video.videoWidth; c.height=video.videoHeight;
      ctx.scale(-1,1); ctx.drawImage(video,-c.width,0,c.width,c.height);
      c.toBlob(blob=>{
        const url=URL.createObjectURL(blob); const a=document.createElement('a');
        a.href=url; a.download=`palm_${Date.now()}.jpg`; document.body.appendChild(a); a.click();
        a.remove(); URL.revokeObjectURL(url);
        statusEl.textContent='‚úÖ Captured'; statusEl.className='status ready';
      },'image/jpeg',0.9);
    }

    window.addEventListener('load', startCamera);
    document.addEventListener('visibilitychange', ()=>{ if(document.hidden) stopCamera(); else if(!stream) startCamera(); });
    window.addEventListener('resize', ()=>{}); // overlay recalculates via CTM
function positionTargetsOnOutline() {
    const path = palmOutline;                     // green silhouette path
    if (!path) return;

    const L = path.getTotalLength();
    const N = 2400;                               // dense sampling along the path
    const pts = new Array(N);

    // sample once (viewBox units)
    for (let i = 0; i < N; i++) {
      const p = path.getPointAtLength((i / (N - 1)) * L);
      pts[i] = { x: p.x, y: p.y, i };
    }

    // simple 1-D smoothing on y so local minima are stable
    const k = 7;                                  // half-window
    const ys = pts.map(p => p.y);
    const ysm = ys.slice();
    for (let i = 0; i < N; i++) {
      let s = 0, c = 0;
      for (let j = -k; j <= k; j++) {
        const t = i + j;
        if (t >= 0 && t < N) { s += ys[t]; c++; }
      }
      ysm[i] = s / c;
    }

    const box = path.getBBox();
    const topGate = box.y + box.height * 0.72;    // ignore points too low (wrist area)

    // collect local minima (highest points on each finger)
    const cand = [];
    for (let i = 1; i < N - 1; i++) {
      if (ysm[i] < ysm[i - 1] && ysm[i] < ysm[i + 1] && ysm[i] < topGate) {
        cand.push({ x: pts[i].x, y: pts[i].y, score: -ysm[i], i });
      }
    }

    // prefer higher tips; keep at least minDx apart so we don't pick the same finger twice
    cand.sort((a, b) => a.score - b.score);       // lower y = higher score
    const minDx = box.width * 0.12;               // separation between fingers
    const picked = [];
    for (const c of cand) {
      if (picked.every(p => Math.abs(p.x - c.x) > minDx)) picked.push(c);
      if (picked.length === 5) break;
    }

    // if we somehow got fewer than 5 (very rare), just take the best by x-separation
    if (picked.length < 5) {
      const extra = cand.filter(c => !picked.includes(c));
      for (const c of extra) {
        if (picked.every(p => Math.abs(p.x - c.x) > minDx * 0.6)) picked.push(c);
        if (picked.length === 5) break;
      }
    }

    // thumb -> pinky = left -> right in the (unmirrored) SVG
    picked.sort((a, b) => a.x - b.x);

    // place target circles slightly down so they sit on the stroke visually
    const dy = 4;
    for (let i = 0; i < 5; i++) {
      const p = picked[4-i] || { x: box.x, y: box.y }; // fallback
      targetEls[i].setAttribute('cx', p.x);
      targetEls[i].setAttribute('cy', p.y + dy);
    }
    // --- PALM TARGET (t5) ---
    // Put the palm dot low in the silhouette, centered under the middle finger tip.
    const middle = targetEls[2]; // t2 == middle finger
    const midX = Number(middle.getAttribute('cx')) || (box.x + box.width * 0.5);
    const palmY = box.y + box.height * 0.63; // 0.80‚Äì0.92; raise/lower to taste
    targetEls[5].setAttribute('cx', midX);
    targetEls[5].setAttribute('cy', palmY);

  }

    // Call once everything exists
    window.addEventListener('load', () => {
        startCamera();             // your existing call
        positionTargetsOnOutline();// place black dots on silhouette fingertips
    });

    // Optional: keep them sensible on layout/SVG changes
    window.addEventListener('resize', positionTargetsOnOutline);
  </script>

  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
</body>
</html>
